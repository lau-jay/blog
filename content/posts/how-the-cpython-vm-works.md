+++
title = "Python的幕后#1: CPython VM 是如何工作的"
date = 2020-12-21T10:20:20+08:00
images = []
tags = ["translate"]
categories = ["python"]
draft = true
+++

> [原文](https://tenthousandmeters.com/blog/python-behind-the-scenes-1-how-the-cpython-vm-works/) 
>
> 本文已获原文作者[Victor Skvortsov](https://tenthousandmeters.com/about/)授权

## 引言

你是否想过 当你用`python`命令执行你的程序的时候, 它做了什么?
```shell
$ python script.py
```
这篇文章是一系列试图回答这个问题文章的开端. 我们将会深入CPython的内部(这是Python最流行的实现).
这样我们将更深入的了解语言本身.这是本系列文章的主要目的.如果你熟悉Python和C, 但是并不熟悉CPython
源码, 那么你可能你会发现本文很有趣.

## 什么是CPython并且为什么有人想要学习它呢?

让我们从众所周知的地方开始谈起。 CPython是C语言实现的Python解释器. 它是Python的一种实现, 其他的实现有PyPy, Jython, IronPython等等. CPython是最原始, 维护最久和使用最广的一种实现。

CPython实现了Python, 但是什么是Python? 一个简单的回答是: Python是一种编程语言。当正确地提出相同的问题时，答案变得更加细微：什么定义了Python是什么？ Python与C之类的语言不同，它没有正式的规范。 最接近它的是Python语言参考，它以以下开头:

>当我尝试尽可能精确时，我选择对语法和词法分析以外的所有内容使用英语而不是正式的规范。 这应该使普通读者更容易理解文档，但会存在歧义。 因此，如果您是来自火星并试图仅通过本文档重新实现Python，则您可能不得不猜测，实际上您可能最终会实现完全不同的语言。 另一方面，如果您正在使用Python，并且想知道关于该语言特定区域的确切规则是什么，那么您肯定可以在这里找到它们。

因此，Python并非仅由其语言参考来定义。说Python是由其参考实现CPython定义的，这也是错误的，因为有些实现细节不是该语言的一部分。依赖引用计数的垃圾收集器就是一个例子。 由于没有单一的事实来源，因此我们可以说Python的一部分是由Python语言参考定义的，另一部分是由其主要实现CPython定义的。

这种推论似乎有些古怪，但我认为弄清我们将要研究的主题的关键作用至关重要。 但是，您可能仍然想知道为什么我们应该研究它。 除了好奇心外，我还发现以下原因:

* 纵览全貌可以更深入地了解该语言。 如果您了解Python的某些实现细节，那么掌握Python的某些特性就容易得多

* 语言实现细节在实践中很重要。 当人们想了解语言的适用性及其局限性，估计性能或检测对效率的影响时，对象的存储方式，垃圾收集器的工作方式以及如何协调多个线程是非常重要的主题。

* CPython提供了Python / C API，该API允许使用C扩展Python并将Python嵌入C中。要有效地使用此API，程序员需要对CPython的工作方式有充分的了解。

## 了解CPython如何工作需要什么?

CPython的设计易于维护。 新手当然可以期望能够阅读源代码并了解其功能。 但是，可能需要一些时间。 通过编写本系列文章，希望对您有所帮助。



## 该系列的讲解方式

我选择采取自上而下的方式。 在这一部分中，我们将探讨CPython虚拟机（VM）的核心概念。 接下来，我们将了解CPython如何将python源代码编译为VM可以执行的程序。 之后，我们将熟悉CPython源代码，并逐步执行一个程序，在此过程中研究解释器的主要部分。 最终，我们将能够逐一挑选出语言的不同方面，并查看它们是如何实现的。 这绝不是一个严格的计划，而是我的大概想法。

Note: 在这篇文章中，我指的是CPython 3.9。 随着CPython的发展，某些实现细节肯定会发生变化。 我将尝试跟踪重要的更改并添加更新说明。

## 概览

Python程序的执行大致包括三个阶段:

1. 初始化
2. 编译
3. 解释

在初始化阶段，CPython将初始化运行Python所需的数据结构。 它还准备诸如内置类型，配置和加载内置模块，设置导入系统等功能。 这是一个非常重要的阶段，由于其服务性质，CPython的探索者经常忽略它。

接下来是编译阶段。 从不产生机器代码的意义上讲，CPython是解释器，而不是编译器。 但是，解释器通常在执行之前将源代码转换为某种中间表示。 CPython也是如此。 此翻译阶段执行的操作与典型编译器相同：解析源代码并构建AST（抽象语法树），从AST生成字节码，甚至执行一些字节码优化。

在进行下一阶段之前，我们需要了解什么是字节码。 字节码是一系列指令。 每条指令由两个字节组成：一个字节用于操作码，一个字节用于参数。 考虑一个例子：

```python
def g(x):
  return x + 3
```

CPython将函数`g()`的函数体转换为以下字节序列：[124，0，100，1，23，0，83，0]。 如果我们运行标准库dis对其进行反汇编，则将获得以下信息：

```shell
$ python -m dis example1.py
...
2           0 LOAD_FAST            0 (x)
            2 LOAD_CONST           1 (3)
            4 BINARY_ADD
            6 RETURN_VALUE
```

LOAD_FAST操作码对应于字节124，参数为0。LOAD_CONST操作码对应于字节100，参数为1。BINARY_ADD和RETURN_VALUE指令始终分别编码为（23，0）和（83，0），因为他们不需要参数。

CPython的核心是执行字节码的虚拟机。 通过查看前面的示例, 您可能会猜测它是如何工作的。 CPython的VM是基于堆栈的。 这意味着它使用堆栈执行指令来存储和检索数据。 LOAD_FAST指令将局部变量压入堆栈。 LOAD_CONST将一个常数压栈。 BINARY_ADD从堆栈中弹出两个对象，将它们加起来并将结果压回去。 最后，RETURN_VALUE弹出堆栈中的所有内容，并将结果返回给其调用方。

字节码执行发生在巨大的求值循环(evaluation loop)中，该循环在有指令执行时运行。 它将在产生值或产生错误时停止。

这样的简短概述会引起了很多问题：

* LOAD_FAST和LOAD_CONST操作码的参数是什么意思？ 他们是指数吗？ 他们索引什么？
* VM是否在堆栈上放置值或对对象的引用？
* CPython如何知道x是局部变量？
* 如果参数太大而无法容纳单个字节怎么办？
* 将两个数字相加的指令是否与连接两个字符串相同？ 如果是，那么VM如何区分这些操作？

为了回答这些以及其他有趣的问题，我们需要研究CPython VM的核心概念。

## Code objects, function objects, frames

### Code objects

### function objects

### frames